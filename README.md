# Orbital 


## Introduction

Orbital is a Python library for constructing and rendering curves on surfaces.   

This library depends on [SageMath](https://SageMath.org) and [Povray](http://povray.org) libraries.

## Installation

* Install Sage from [SageMath](https://SageMath.org).
We assume that `sage` is accessible from your commandline interface.

* Install [Povray](http://povray.org).
We assume that `povray` is accessible from your commandline interface.

* Install the `orbital` package: 
```    
sage -pip install orbital
```    
If you do not have root access use the following command instead:
```    
sage -pip install --user orbital
```    

* We advice to upgrade the `orbital` package regularly:
```
sage -pip install --upgrade orbital
```
 
* To execute some [usecases](https://github.com/niels-lubbes/moebius_aut/blob/master/orbital/src/orbital/__main__.py) type:
```    
sage -python -m orbital
```

* For showing which files were installed 
or for uninstalling the `orbital` package, 
use one of the following commands:
```
sage -pip show --files orbital
sage -pip uninstall orbital
```


## Examples

See also [this file](https://github.com/niels-lubbes/orbital/blob/master/orbital/src/orbital/__main__.py) 
for example usecases. 
See the [source code](https://github.com/niels-lubbes/orbital/blob/master/orbital/src/orbital)
the io-specification of each function.
The [test functions](https://github.com/niels-lubbes/orbital/blob/master/orbital/src/tests)
might be informative for how to call each function.

For running the examples below, either copy paste the code into the Sage interface or run them as a Python module:

    sage -python -m my_module_name.py


### Example 1: Computing and rendering a hexagonal web of conics on a surface. 

Creates povray image of a linear projection to 3-space 
of a smooth sextic del Pezzo surface in the projective 5-sphere. 
This surface contains 3 families of conics that form a hexagonal web. 
We render the families of conics by using Povray.

```python
# We explicitly import the required libraries.
#
from linear_series.class_linear_series import LinearSeries
from linear_series.class_base_points import BasePointTree
from linear_series.class_poly_ring import PolyRing

from orbital.surface_in_quadric import get_surf
from orbital.surface_in_quadric import approx_QQ
from orbital.surface_in_quadric import get_prj_mat
from orbital.surface_in_quadric import get_proj

from orbital.povray.class_pov_input import PovInput
from orbital.povray.povray import create_pov
from orbital.povray.povray_aux import get_time_str

from orbital.sage_interface import sage_QQ
from orbital.sage_interface import sage_var
from orbital.sage_interface import sage_vector
from orbital.sage_interface import sage_pi

# Compute linear series on P^1xP^1 of bi-degree (2,2) and (1,1)
# passing through two complex conjugate base points. 
# The linear series ls_AB of bi-degree (2,2) defines a map 
# that parametrizes a surface isomorphic to the blow up of P^1xP^1 
# in two points. This surface is a del Pezzo surface of degree 6. 
# Its ideal is generated by quadratic forms.
#
a0 = PolyRing( 'x,y,v,w', True ).ext_num_field( 't^2 + 1' ).root_gens()[0]
bp_tree = BasePointTree( ['xv', 'xw', 'yv', 'yw'] )
bp = bp_tree.add( 'xv', ( -a0, a0 ), 1 )
bp = bp_tree.add( 'xv', ( a0, -a0 ), 1 )
ls_AB = LinearSeries.get( [2, 2], bp_tree )
ls_CB = LinearSeries.get( [1, 1], bp_tree )

# We compute a surface that is contained in a hyperquadric of 
# signature (6,1) and that is the projection of the surface
# parametrized by ls_AB. The quadratic form of signature (6,1)
# has associated matrix M with orthogonal diagonalization
# M=U.T*J*U, where J is a diagonal matrix.
#
dct = get_surf( ls_AB, ( 6, 1 ) )
U, J = dct['UJ']
U.swap_rows( 0, 6 );J.swap_columns( 0, 6 );J.swap_rows( 0, 6 )
assert dct['M'] == approx_QQ( U.T * J * U )

# In order to visualize the surface we project it to 3-space
# with a linear map defined by the matrix P. The list 
# pmz_AB_lst defines a map that parametrizes the projected surface.
# If we fix the 1st and 2nd parameter we obtain a family of conics    
# called A and B respectively.
#
approxU = approx_QQ( U )
P = get_prj_mat( 4, 7, 0 )
P[0, 6] = -1;P[3, 3] = 0;P[3, 4] = 1
P = P * approxU
f_xyz, pmz_AB_lst = get_proj( dct['imp_lst'], dct['pmz_lst'], P )

# We compute a reparametrization pmz_CB_lst of the projected surface.
# If we fix the 1st and 2nd parameter we obtain a family of conics    
# called C and B respectively. 
# See also orbital.surface_in_quadric.get_S1xS1_pmz().
#
ring = PolyRing( 'x,y,v,w,c0,s0,c1,s1' )  # construct polynomial ring with new generators
x, y, v, w, c0, s0, c1, s1 = ring.gens()
X = 1 - s0; Y = c0; V = 1 - s1; W = c1;
CB_dct = { x:X, y:Y, v:X * W + Y * V, w: X * V - Y * W }
pmz_CB_lst = [ p.subs( CB_dct ) for p in ring.coerce( ls_AB.pol_lst )]
pmz_CB_lst = list( P * dct['Q'] * sage_vector( pmz_CB_lst ) )

# In order to render the projected surface we create a PovInput object.
#
pin = PovInput()
pin.path = './' + get_time_str() + '_dp6_smooth/'
pin.fname = 'orb'
pin.scale = 1
pin.cam_dct['location'] = ( 0, 0, sage_QQ( -21 ) / 10 )
pin.cam_dct['lookat'] = ( 0, 0, 0 )
pin.cam_dct['rotate'] = ( 310, 0, 0 )
pin.shadow = True
pin.light_lst = [( 0, 0, -5 ), ( 0, -5, 0 ), ( -5, 0, 0 ), ( 0, 0, 5 ), ( 0, 5, 0 ), ( 5, 0, 0 ) ]
pin.axes_dct['show'] = False
pin.axes_dct['len'] = 1.2
pin.height = 400
pin.width = 800
pin.quality = 11
pin.ani_delay = 1
pin.impl = None
pin.pmz_dct['A'] = ( pmz_AB_lst, 0 )
pin.pmz_dct['B'] = ( pmz_AB_lst, 1 )
pin.pmz_dct['C'] = ( pmz_CB_lst, 0 )
v0_lst = [ ( sage_QQ( i ) / 180 ) * sage_pi for i in range( 0, 360, 10 )]
v1_lst = [ ( sage_QQ( i ) / 180 ) * sage_pi for i in range( 0, 360, 15 )]
pin.curve_dct['A'] = {'step0':v0_lst, 'step1':v1_lst, 'prec':10, 'width':0.02}
pin.curve_dct['B'] = {'step0':v0_lst, 'step1':v1_lst, 'prec':10, 'width':0.02}
pin.curve_dct['C'] = {'step0':v0_lst, 'step1':v1_lst, 'prec':10, 'width':0.02}
col_A = ( 0.4, 0.0, 0.0, 0.0 )
col_B = ( 0.2, 0.3, 0.2, 0.0 )
col_C = ( 0.8, 0.6, 0.2, 0.0 )
pin.text_dct['A'] = [True, col_A, 'phong 0.2 phong_size 5' ]
pin.text_dct['B'] = [True, col_B, 'phong 0.2 phong_size 5' ]
pin.text_dct['C'] = [True, col_C, 'phong 0.2 phong_size 5' ]

# raytrace all families of conics on the projected surface using Povray.
# This takes a long time.
#
create_pov( pin, ['A', 'B', 'C'] )

```
Output:
    
    [(-2)*x0^2 + 2*x1*x2 + 2*x3*x4 - x5*x6 - x7*x8]
    [[4, 5]]

![output image](https://raw.githubusercontent.com/niels-lubbes/orbital/master/orbital/img/deg6-dp6.png?token=AX_Io9IlHHRjrwsxr_I03zGKcN8FF31Eks5azdscwA%3D%3D "Hexagonal web on sextic del Pezzo surface")    
    

